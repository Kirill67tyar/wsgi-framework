"""
----------------------------------------- 1 ---------------------------------------------

WSGI

1.1--- Введение
1.2--- Зачем нужен WSGI
1.3--- Характеристики WSGI
1.4--- Ферймворк vs библиотека
1.5--- Код WSGI-обработчика
1.6--- Что есть фреймворк?


1.1------------------------------ Введение

Серверная часть принимает запрос и должна как-то его обработать

Но каждый Web-сервер (front-end сервер (nginx, apache)) имеет свои особенности

Старый подход заключался в том, что раньше создавали под каждый web-сервер
отдельно web-приложение.

Поэтому придумали протокол, по которому сервера универсально выполняли бы
обработку всех запросов

И этот протокол - WSGI
(для каждого яп он всё таки свой)


1.2------------------------------ Зачем нужен WSGI

Параметры запроса, которые пришли вместе с HTTP запросом
(заголовки, ip, и т.д.)
Нужно отдать Python приложению

Смотри:
C:\Users\kiril\Desktop\Job\django_repeat_07\wsgi-framework\src\common\media\web_path.png

C:\Users\kiril\Desktop\Job\django_repeat_07\wsgi-framework\src\common\media\отличная_схема

C:\Users\kiril\Desktop\Job\django_repeat_07\wsgi-framework\src\common\media\развертывание_WSGI_хороший_вариант

Когда nginx осуществляет с ним взаиможействие,
он отправляет байты (но в виде HTTP запроса)

Но приложению на Python было бы удобнее работать с другим форматом,
не с байтами, а со словарём

Т.е. необходимо приложение, коннектор, которое бы трансформировало байты
в словарь

И этими коннекторами являются:

 -- uWSGI
 -- Gunicorn

 ?? Т.е. иными словами WSGI парсит HTTP и приобразовывает инфу о запросе в словарь
    в формате CGI. (т.е. в формате переменных окружения).
    Но уже на стороне backend-сервера.
    Возможно это делает не WSGI а Gunicorn? В любом случае это кто-то должен делать

Коннектор совершает конвертацию байтов в словарь и передаёт уже на Python приложение

Под приложением на Python имеется ввиду код фреймворка и код приложения.

Ответ, когда мы произвели все необходимые действия с db (CRUD)
тоже передаётся WSGI-коннектору

WSGI-коннектор делает ответ приемлимым для frontend-сервера

Работу приложения WSGI регламентирует специальный стандарт - pep-333
https://peps.python.org/pep-0333/
https://lectureswww.readthedocs.io/5.web.server/wsgi.html#:~:text=WSGI%20%E2%80%94%20%D1%81%D1%82%D0%B0%D0%BD%D0%B4%D0%B0%D1%80%D1%82%20%D0%B2%D0%B7%D0%B0%D0%B8%D0%BC%D0%BE%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D1%8F%20%D0%BC%D0%B5%D0%B6%D0%B4%D1%83%20Python,%2D%D1%84%D1%80%D0%B5%D0%B9%D0%BC%D0%B2%D0%BE%D1%80%D0%BA%D0%BE%D0%B2%2C%20%D1%82%D1%83%D0%BB%D0%BA%D0%B8%D1%82%D0%BE%D0%B2%20%D0%B8%20%D0%B1%D0%B8%D0%B1%D0%BB%D0%B8%D0%BE%D1%82%D0%B5%D0%BA.


1.3------------------------------ Характеристики WSGI

 1) WSGI - callable объект (функци или класс с __call__)
 2) WSGI-функция принимает 2 аргумента:
     -- словарь параметров от нашего WSGI фреймворка - environ
     -- функция start_response, которая является обработчиком запроса
        эта функция формирует ответ, и отправляет его на WSGI коннектор и дальше по цепочке
 3) WSGI-функция должна обязательно обеспечивать вызов обработчика запроса start_response
    start_response принимает код ответа и http-заголовки - start_response(status, response_headers)
 4) Возврат тела ответа.

И так:
 -- мы получаем словарь от WSGI-коннектора
 -- обработчик запроса позволяет start_response позволяет сформировать ответ
    на поступивший запрос


1.4------------------------------ Ферймворк vs библиотека

Отличие фреймворка от библиотеки, в том, что фреймворк полностью определяет
архитектуру приложения.
А библиотека просто чемоданчик с инструментами


1.5------------------------------ Код WSGI-обработчика

Смотри здесь:
C:\Users\kiril\Desktop\Job\django_repeat_07\wsgi-framework\src\step_1\simba_framework\main.py


1.6------------------------------ Что есть фреймворк?

Фреймворк минимальной реализации, это - callable объект
выполняющий обработку запросов.
Запросы поступают от web-сервера (frontend-сервера), в байтовом формате
Но через WSGI-коннектор трансформируются в более привычный формат python-объектов словарей
(в виде переменных окружения как в CGI)
С указанным словарём фреймворк делает необхлдимые операции
и запускает соответствующий контроллер, для того url, что ввёл клиент
Происходят работа CRUD с db, строится ответ,
и в байтовом формате, через коннектор отправляется обратно на серверную часть
И транслируется клиенту


"""